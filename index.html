<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Particles</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background: #000; }
    </style>
</head>
<body>
<script>
// 配色（深沉、低明度、灰调）
// 使用 HSB 数组: [Hue, Saturation, Brightness]
// 色调集中在蓝、紫、绿，明度压低，饱和度适中
const monetColors = [
    [210, 20, 40], // 深灰蓝 (像深水)
    [240, 15, 35], // 暗蓝紫 
    [300, 25, 50], // 暗紫红
    [100, 15, 40], // 墨绿
    [60, 20, 50],  // 橄榄绿
    [0, 10, 30]    // 深灰 (用于过渡)
];

let particles = [];
let zOff = 0; // 噪声偏移，控制流动

function setup() {
    createCanvas(windowWidth, windowHeight);
    // 设置颜色模式为 HSB，范围对应上面的配色数组
    colorMode(HSB, 360, 100, 100);
    // 初始背景设为深色
    background(240, 10, 20);
    
    // 生成粒子
    for (let i = 0; i < 300; i++) {
        particles.push(new LifeParticle());
    }
}

function draw() {
    // --- 关键：半透明覆盖层，产生“拖尾/残影”效果 ---
    // 使用深色半透明层覆盖，只擦除部分画面，留下痕迹
    fill(20, 10, 10, 0.1); 
    rect(0, 0, width, height);

    // 更新全局噪声偏移（模拟时间流动）
    zOff += 0.005;

    // 更新和显示所有粒子
    for (let i = particles.length - 1; i >= 0; i--) {
        let p = particles[i];
        
        // 1. 获取力场方向 (使用简单的噪声场，避免复杂计算)
        // 计算当前点在噪声场中的角度
        let angle = noise(p.pos.x * 0.005, p.pos.y * 0.005, zOff) * TWO_PI;
        let force = p5.Vector.fromAngle(angle);
        force.mult(0.2); // 力的大小
        p.follow(force);

        // 2. 更新生命状态
        p.update();

        // 3. 视觉呈现
        p.show();

        // 4. 生命周期管理：死亡与重生
        if (p.isDead()) {
            p.rebirth();
        }
    }
}

// 粒子类
class LifeParticle {
    constructor() {
        // 初始聚集在中心
        this.pos = createVector(width / 2, height / 2);
        this.vel = p5.Vector.random2D().mult(random(0.5, 2));
        this.acc = createVector(0, 0);
        
        // 生命属性
        this.life = 0; 
        this.maxLife = random(200, 600); 
        
        // 视觉属性
        this.size = random(2, 5);
        
        // 从莫奈色盘中随机选择基础色相
        // 修正了之前的 random([array]) 写法，改为索引随机，兼容性更好
        let colorChoice = monetColors[floor(random(monetColors.length))];
        this.hue = colorChoice[0];
        this.sat = colorChoice[1];
        this.bri = colorChoice[2];
        
        this.isBloomed = false;
    }

    // 遵循力场
    follow(vector) {
        let steer = p5.Vector.sub(vector, this.vel);
        steer.limit(0.1);
        this.acc.add(steer);
    }

    update() {
        // 物理更新
        this.vel.add(this.acc);
        this.vel.limit(3);
        this.pos.add(this.vel);
        this.acc.mult(0);

        // 生命流逝
        this.life++;
        
        // 边界处理：循环出现
        if (this.pos.x < 0) this.pos.x = width;
        if (this.pos.x > width) this.pos.x = 0;
        if (this.pos.y < 0) this.pos.y = height;
        if (this.pos.y > height) this.pos.y = 0;

        // 绽放逻辑
        if (this.life > this.maxLife * 0.3 && !this.isBloomed) {
            this.isBloomed = true;
        }
    }

    show() {
        // 计算生命阶段
        let lifeRatio = this.life / this.maxLife;
        
        // --- 动态颜色 ---
        // 基础色相 + 缓慢的色相偏移（模拟光影流动）
        // 饱和度随时间降低（枯萎感）
        let sat = map(lifeRatio, 0, 1, this.sat, this.sat * 0.5);
        // 亮度随时间降低（暮色感），但偶尔闪烁（璀璨）
        let bri = map(lifeRatio, 0, 1, this.bri, this.bri * 0.3);
        
        // 璀璨时刻：在特定生命阶段增加亮度
        if (this.isBloomed && sin(frameCount * 0.05 + this.birthTime) > 0.8) {
            bri += 20;
        }

        // --- 动态大小 ---
        let growth = min(lifeRatio * 2, 1);
        let pulse = 1 + 0.3 * sin(frameCount * 0.1 + this.pos.x * 0.1); // 随机脉动
        let displaySize = this.size * pulse * growth;

        // --- 绘制 ---
        // 使用半透明，产生光晕和拖尾
        noStroke();
        // alpha 通道控制透明度，产生消亡感
        fill(this.hue, sat, bri, 0.6);
        
        // 绘制圆形，旋转产生动态感
        ellipse(this.pos.x, this.pos.y, displaySize, displaySize * 0.6);
    }

    isDead() {
        return this.life >= this.maxLife;
    }

    rebirth() {
        // 重置状态，回到中心
        this.pos.set(width / 2, height / 2);
        this.vel = p5.Vector.random2D().mult(random(1, 3));
        this.life = 0;
        this.maxLife = random(200, 600);
        this.isBloomed = false;
        
        // 随机改变颜色基调，保持多样性
        let colorChoice = monetColors[floor(random(monetColors.length))];
        this.hue = colorChoice[0];
        this.sat = colorChoice[1];
        this.bri = colorChoice[2];
    }
}

function windowResized() {
    resizeCanvas(windowWidth, windowHeight);
}
</script>
</body>
</html>
