<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>生命与织体</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background: #111; }
    </style>
</head>
<body>
<script>
// 特点：高明度，低饱和度，色彩斑斓但柔和
const monetColors = [
    [330, 30, 90], // 柔和的灰粉
    [210, 25, 85], // 灰蓝
    [30, 50, 90],  // 淡金/奶油
    [120, 20, 80], // 灰绿
    [270, 25, 85], // 藕荷色
    [60, 40, 85]   // 黄绿
];

let particles = [];
let flowField = []; // 用于存储噪声场
let zOff = 0; // 3D噪声的z轴偏移，控制整体流动
let scale = 20; // 噪声场的分辨率
let hueShift = 0; // 用于模拟时间流逝的色相偏移

function setup() {
    createCanvas(windowWidth, windowHeight);
    colorMode(HSB, 360, 100, 100, 1);
    background(20, 10, 10);
    
    // 初始化噪声场
    let xoff = 0;
    for (let x = 0; x < width; x += scale) {
        let yoff = 0;
        for (let y = 0; y < height; y += scale) {
            let r = noise(xoff, yoff, zOff) * TWO_PI;
            let v = p5.Vector.fromAngle(r);
            v.setMag(0.5);
            flowField.push(v);
            yoff += 0.1;
        }
        xoff += 0.1;
    }

    // 初始生成粒子
    for (let i = 0; i < 400; i++) {
        particles.push(new LifeParticle());
    }
}

function draw() {
    // 半透明覆盖层，产生长曝光效果
    fill(20, 10, 10, 0.05);
    rect(0, 0, width, height);

    // 更新噪声场（模拟音乐的流动）
    zOff += 0.005;
    let xoff = 0;
    let index = 0;
    for (let x = 0; x < width; x += scale) {
        let yoff = 0;
        for (let y = 0; y < height; y += scale) {
            let r = noise(xoff, yoff, zOff) * TWO_PI;
            let v = p5.Vector.fromAngle(r);
            // 随机性控制：根据音乐织体改变力场强度
            let strength = map(noise(xoff * 0.5, yoff * 0.5, zOff), 0, 1, 0.2, 1.5);
            v.setMag(strength);
            flowField[index] = v;
            yoff += 0.1;
            index++;
        }
        xoff += 0.1;
    }

    // 更新和显示所有粒子
    for (let i = particles.length - 1; i >= 0; i--) {
        let p = particles[i];
        
        // 1. 获取力场方向 (模拟音乐的引导)
        let vx = floor(p.pos.x / scale);
        let vy = floor(p.pos.y / scale);
        let vIndex = vy * floor(width / scale) + vx;
        if (flowField[vIndex]) {
            p.follow(flowField[vIndex]);
        }

        // 2. 粒子间相互作用 (模拟织体密度)
        p.interact(particles);

        // 3. 更新生命状态
        p.update();

        // 4. 视觉呈现
        p.show();

        // 5. 生命周期管理：死亡与重生 (模拟呼吸)
        if (p.isDead()) {
            // 死亡后在中心重生，模拟花朵枯萎后种子再生
            p.rebirth();
        }
    }

    // 动态标题显示（可选）
    // fill(240, 50, 90, 0.5);
    // noStroke();
    // textSize(16);
    // text("聆听色彩的呼吸...", 20, 20);
}

// 粒子类：代表一个具有生命周期的生命体
class LifeParticle {
    constructor() {
        // 初始聚集在中心（聚合态）
        this.pos = createVector(width / 2 + random(-10, 10), height / 2 + random(-10, 10));
        this.vel = p5.Vector.random2D();
        this.vel.mult(random(0.5, 2));
        this.acc = createVector(0, 0);
        
        // 生命属性
        this.life = 0; // 生命计时器
        this.maxLife = random(300, 800); // 随机寿命，模拟不同生长周期
        this.birthTime = frameCount;
        
        // 视觉属性
        this.size = random(2, 6);
        this.baseHue = random([60, 120, 210, 330]); // 从莫奈色盘中随机选择基础色相
        this.isBloomed = false; // 是否已经绽放
    }

    // 遵循力场
    follow(vector) {
        let steer = p5.Vector.sub(vector, this.vel);
        steer.limit(0.1);
        this.acc.add(steer);
    }

    // 粒子间相互作用（模拟音乐的织体：重复与和声）
    interact(others) {
        let repel = createVector(0, 0);
        let align = createVector(0, 0);
        let count = 0;

        for (let other of others) {
            let d = p5.Vector.dist(this.pos, other.pos);
            
            // 排斥力：防止过度拥挤（模拟音符的清晰度）
            if (d > 0 && d < 30) {
                let force = p5.Vector.sub(this.pos, other.pos);
                force.div(d); 
                repel.add(force);
            }
            
            // 对齐：模拟音乐动机的重复
            if (d > 30 && d < 80) {
                align.add(other.vel);
                count++;
            }
        }

        if (count > 5) {
            align.div(count);
            align.setMag(1);
            let steer = p5.Vector.sub(align, this.vel);
            steer.limit(0.05);
            this.acc.add(steer);
        }

        repel.setMag(0.5);
        this.acc.add(repel);
    }

    update() {
        // 物理更新
        this.vel.add(this.acc);
        this.vel.limit(4);
        this.pos.add(this.vel);
        this.acc.mult(0);

        // 生命流逝
        this.life++;
        
        // 边界处理：像宇宙一样循环
        if (this.pos.x < 0) this.pos.x = width;
        if (this.pos.x > width) this.pos.x = 0;
        if (this.pos.y < 0) this.pos.y = height;
        if (this.pos.y > height) this.pos.y = 0;

        // 绽放逻辑：模拟花朵盛开
        if (this.life > this.maxLife * 0.3 && !this.isBloomed) {
            this.isBloomed = true;
        }
    }

    show() {
        // 计算生命阶段
        let lifeRatio = this.life / this.maxLife;
        let growth = min(lifeRatio * 2, 1); // 前半段生长，后半段维持
        
        // 动态颜色：模拟莫奈的光影变化
        // 基础色相 + 缓慢的色相偏移（模拟时间流逝）
        let hue = (this.baseHue + sin(frameCount * 0.01 + this.birthTime) * 10) % 360;
        let sat = map(lifeRatio, 0, 1, 30, 10); // 饱和度随时间降低（枯萎感）
        let bri = map(lifeRatio, 0, 1, 90, 60); // 亮度随时间降低（暮色感）
        
        // 如果是绽放期，增加闪烁
        if (this.isBloomed && frameCount % 60 < 10) {
            bri += 20;
        }

        // 动态大小：模拟呼吸和脉动（音阶的律动）
        let pulse = 1 + 0.2 * sin(frameCount * 0.05 + this.birthTime);
        let displaySize = this.size * pulse * growth;

        // 半透明叠加，产生光晕
        noStroke();
        fill(hue, sat, bri, 0.7);
        
        // 使用圆角矩形或圆形，根据状态改变形态
        if (displaySize > 4) {
            // 使用ellipse模拟光点
            ellipse(this.pos.x, this.pos.y, displaySize, displaySize * 0.5);
        } else {
            point(this.pos.x, this.pos.y);
        }
    }

    isDead() {
        return this.life >= this.maxLife;
    }

    rebirth() {
        // 重置状态，回到中心
        this.pos.set(width / 2, height / 2);
        this.vel = p5.Vector.random2D().mult(random(1, 3));
        this.life = 0;
        this.maxLife = random(300, 800);
        this.birthTime = frameCount;
        this.isBloomed = false;
        // 随机改变颜色基调
        this.baseHue = random([60, 120, 210, 330]);
    }
}

function windowResized() {
    resizeCanvas(windowWidth, windowHeight);
}
</script>
</body>
</html>
