<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Standalone</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #0a0a14; /* 深蓝背景，模拟夜景 */
            touch-action: none;
        }
        canvas { 
            display: block; 
        }
    </style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/three@0.137.5/build/three.min.js"></script>
<script>
    // 稳定的版本锁定，避免本地加载失败
    console.log("Three.js version:", THREE.REVISION);

    // --- 场景初始化 ---
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio || 1);
    // 关键：关闭物理灯光衰减，手动控制辉光
    renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.toneMapping = THREE.LinearToneMapping; // 避免过曝
    document.body.appendChild(renderer.domElement);

    // --- 相机位置 ---
    camera.position.z = 40;

    // --- 配色 (数组存储) ---
    const monetColors = [
        [0.1, 0.15, 0.3],   // 深蓝
        [0.2, 0.4, 0.6],    // 水蓝
        [0.5, 0.3, 0.6],    // 紫罗兰
        [0.8, 0.7, 0.9],    // 柔粉
        [0.1, 0.3, 0.2],    // 墨绿
        [0.9, 0.8, 0.5]     // 柠檬黄
    ];

    // --- 粒子数量 ---
    const COUNT = 6000;
    const geometry = new THREE.BufferGeometry();

    // 位置
    const positions = new Float32Array(COUNT * 3);
    // 大小 (让每个粒子大小不同)
    const sizes = new Float32Array(COUNT);
    // 颜色索引 (因为不能直接传数组进shader uniform，用索引查表)
    const colorIds = new Uint8Array(COUNT);
    // 生命值/衰减系数 (控制闪烁和消亡)
    const alphas = new Float32Array(COUNT);

    for (let i = 0; i < COUNT; i++) {
        const i3 = i * 3;
        
        // --- 位置：环形分布 (比球形更有画面感) ---
        const angle = Math.random() * Math.PI * 2;
        const radius = Math.random() * 25 + 10;
        // Z轴稍微分散
        const z = (Math.random() - 0.5) * 20;
        
        positions[i3] = Math.cos(angle) * radius;
        positions[i3 + 1] = Math.sin(angle) * radius;
        positions[i3 + 2] = z;

        // --- 大小：随机大小 ---
        sizes[i] = Math.random() * 3 + 0.2; // 0.2px 到 3.2px

        // --- 颜色：随机索引 ---
        colorIds[i] = Math.floor(Math.random() * monetColors.length);

        // --- 透明度：随机初始相位 ---
        alphas[i] = Math.random();
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
    geometry.setAttribute('colorId', new THREE.BufferAttribute(colorIds, 1));
    geometry.setAttribute('alpha', new THREE.BufferAttribute(alphas, 1));

    // --- 自定义着色器材质 (核心：立体光影 + 颗粒噪波) ---
    const material = new THREE.ShaderMaterial({
        uniforms: {
            time: { value: 0.0 },
            resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }
        },
        vertexShader: `
            attribute float size;
            attribute float colorId;
            attribute float alpha;
            varying vec3 vColor;
            varying float vAlpha;
            varying vec2 vUv;
            void main() {
                vUv = uv;
                vAlpha = alpha;
                // 根据索引获取颜色 (手动查表)
                if(colorId == 0.0) vColor = vec3(0.1, 0.15, 0.3);
                else if(colorId == 1.0) vColor = vec3(0.2, 0.4, 0.6);
                else if(colorId == 2.0) vColor = vec3(0.5, 0.3, 0.6);
                else if(colorId == 3.0) vColor = vec3(0.8, 0.7, 0.9);
                else if(colorId == 4.0) vColor = vec3(0.1, 0.3, 0.2);
                else vColor = vec3(0.9, 0.8, 0.5);

                // 动态位置：让粒子漂浮
                vec3 pos = position;
                pos.x += sin(time * 0.5 + position.x * 0.1) * 3.0;
                pos.y += cos(time * 0.3 + position.y * 0.1) * 3.0;
                pos.z += sin(time * 0.7 + position.z * 0.1) * 3.0;

                vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                // 距离越近粒子越大
                gl_PointSize = size * (150.0 / length(mvPosition.xyz));
                gl_Position = projectionMatrix * mvPosition;
            }
        `,
        fragmentShader: `
            uniform float time;
            varying vec3 vColor;
            varying float vAlpha;
            // --- 颗粒噪波函数 (核心：制造麻点感) ---
            float noise(vec2 p) {
                return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
            }
            void main() {
                // --- 1. 创建圆形 (消除条形) ---
                // gl_PointCoord 是 [0,1] 区间，转换为 [-1,1]
                vec2 uv = gl_PointCoord * 2.0 - 1.0;
                float dist = dot(uv, uv); // 距离中心的距离 (平方)
                
                // 如果是条形，说明是方形。我们强制裁剪成圆形，边缘加点噪波模拟颗粒轮廓
                if(dist > 1.0) discard; 

                // --- 2. 立体光影模拟 ---
                // 模拟球体的法线向量 (z分量为 sqrt(1-u^2-v^2))
                float z = sqrt(1.0 - dist);
                vec3 normal = normalize(vec3(uv, z));
                
                // 假设光源在左上角
                vec3 lightDir = normalize(vec3(0.5, 0.5, 1.0));
                // 漫反射光照
                float diff = max(dot(normal, lightDir), 0.0) * 0.6 + 0.4; // 0.4 是环境光

                // --- 3. 颗粒纹理叠加 ---
                // 使用高频噪波给粒子表面加“麻点”
                float grain = noise(gl_PointCoord * 10.0); 
                grain = mix(0.8, 1.2, grain); // 调整颗粒对比度
                diff *= grain; // 光照乘以颗粒

                // --- 4. 璀璨消亡效果 (残影) ---
                // 模拟粒子闪烁：使用正弦波控制透明度，越小的粒子闪烁越快
                float pulse = sin(time * 2.0 + vAlpha * 10.0) * 0.5 + 0.5;
                // 残影拖尾：利用 alpha 混合
                float alphaFactor = (vAlpha + pulse * 0.5) * 0.8;

                // --- 5. 辉光模拟 (关键：之前黑屏是因为用了BloomPass，现在手写) ---
                // 在边缘增加一层辉光
                float glow = 1.0 - smoothstep(0.7, 1.0, dist); 
                glow *= 0.5; // 辉光强度

                // 最终颜色
                vec3 finalColor = vColor * diff * (1.0 + glow); // 颜色乘以光照和辉光
                gl_FragColor = vec4(finalColor, alphaFactor);
                
                // 深度写入关闭，防止黑屏遮挡
                gl_FragColor.a *= 1.0 - dist; // alpha 从中心到边缘渐变为0
            }
        `,
        blending: THREE.AdditiveBlending,
        depthTest: true,
        depthWrite: false, // 关键修复：解决黑屏遮挡问题
        transparent: true,
        // side: THREE.DoubleSide // 点精灵默认就是双面
    });

    const cloud = new THREE.Points(geometry, material);
    scene.add(cloud);

    // --- 动画 ---
    function animate() {
        requestAnimationFrame(animate);
        const t = performance.now() * 0.001; // 时间(秒)
        
        material.uniforms.time.value = t;
        
        // 缓慢旋转
        cloud.rotation.y = t * 0.1;
        cloud.rotation.x = Math.sin(t * 0.2) * 0.2;

        renderer.render(scene, camera);
    }
    animate();

    // --- 窗口自适应 ---
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        material.uniforms.resolution.value.set(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>
