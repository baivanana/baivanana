<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Life and Particles</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        canvas { display: block; }
    </style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/postprocessing/EffectComposer.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/postprocessing/RenderPass.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/postprocessing/UnrealBloomPass.js"></script>
<script>
    // --- 场景初始化 ---
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    // --- 相机位置 ---
    camera.position.z = 30;

    // --- 配色 ---
    const colors = [
        new THREE.Color(0.1, 0.1, 0.3),   // 深蓝夜空
        new THREE.Color(0.2, 0.4, 0.6),   // 水波蓝
        new THREE.Color(0.8, 0.6, 0.9),   // 柔和紫光
        new THREE.Color(0.9, 0.9, 0.4),   // 柠檬黄光
        new THREE.Color(0.1, 0.3, 0.2),   // 暗绿荷叶
    ];

    // --- 生成噪波纹理 (模拟颗粒感) ---
    function generateTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 32;
        canvas.height = 32;
        const ctx = canvas.getContext('2d');
        
        // 绘制中心亮、边缘暗的圆形，模拟颗粒
        const gradient = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
        gradient.addColorStop(0, 'white');
        gradient.addColorStop(1, 'transparent');
        
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 32, 32);
        
        // 添加一点噪点颗粒感
        for(let i=0; i<100; i++) {
            const x = Math.random() * 32;
            const y = Math.random() * 32;
            ctx.fillStyle = `rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},0.5)`;
            ctx.fillRect(x, y, 1, 1);
        }
        
        return new THREE.CanvasTexture(canvas);
    }

    // --- 粒子系统 ---
    const particleCount = 8000;
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(particleCount * 3);
    const sizes = new Float32Array(particleCount);
    const colorArray = new Float32Array(particleCount * 3);
    const alphas = new Float32Array(particleCount); // 控制透明度变化

    for (let i = 0; i < particleCount; i++) {
        const i3 = i * 3;
        // 随机位置 (球形分布)
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.random() * Math.PI;
        const radius = Math.random() * 15 + 5;
        
        positions[i3] = Math.sin(phi) * Math.cos(theta) * radius;
        positions[i3 + 1] = Math.sin(phi) * Math.sin(theta) * radius;
        positions[i3 + 2] = Math.cos(phi) * radius;

        // 随机大小 (大小变化)
        sizes[i] = Math.random() * 3 + 0.5;

        // 随机颜色
        const col = colors[Math.floor(Math.random() * colors.length)];
        colorArray[i3] = col.r;
        colorArray[i3 + 1] = col.g;
        colorArray[i3 + 2] = col.b;

        // 初始透明度
        alphas[i] = 1.0;
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colorArray, 3));
    geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
    geometry.setAttribute('alpha', new THREE.BufferAttribute(alphas, 1));

    // --- 着色器材质 (核心：立体光影 + 残影) ---
    const material = new THREE.ShaderMaterial({
        uniforms: {
            pointTexture: { value: generateTexture() },
            time: { value: 0.0 }
        },
        vertexShader: `
            attribute float size;
            attribute vec3 color;
            attribute float alpha;
            varying vec3 vColor;
            varying float vAlpha;
            void main() {
                vColor = color;
                vAlpha = alpha;
                vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                // 根据距离调整大小，产生透视感
                gl_PointSize = size * (100.0 / -mvPosition.z);
                gl_Position = projectionMatrix * mvPosition;
            }
        `,
        fragmentShader: `
            uniform sampler2D pointTexture;
            varying vec3 vColor;
            varying float vAlpha;
            void main() {
                vec4 texColor = texture2D(pointTexture, gl_PointCoord);
                // 立体光照模拟：中心亮，边缘暗
                float r = gl_PointCoord.x - 0.5;
                float s = gl_PointCoord.y - 0.5;
                float dist = length(vec2(r, s));
                float centerGlow = 1.0 - smoothstep(0.4, 0.5, dist);
                
                // 残影效果：根据 alpha 值控制辉光
                gl_FragColor = vec4(vColor, vAlpha * texColor.a * centerGlow);
                // 模拟璀璨消亡：当 alpha 低时，增加一点亮光
                if(vAlpha < 0.3) {
                    gl_FragColor.rgb += 0.5 * (1.0 - vAlpha); // 消亡时更亮
                }
            }
        `,
        blending: THREE.AdditiveBlending,
        depthTest: true,
        transparent: true,
        vertexColors: true
    });

    const particles = new THREE.Points(geometry, material);
    scene.add(particles);

    // --- 后期处理：辉光 (Bloom) ---
    const composer = new EffectComposer(renderer);
    const renderPass = new RenderPass(scene, camera);
    composer.addPass(renderPass);

    const bloomPass = new UnrealBloomPass(
        new THREE.Vector2(window.innerWidth, window.innerHeight),
        1.5, // 强度
        0.4, // 半径
        0.85 // 阈值
    );
    composer.addPass(bloomPass);

    // --- 动画控制 ---
    let time = 0;
    function animate() {
        requestAnimationFrame(animate);
        
        time += 0.005;
        material.uniforms.time.value = time;

        // 缓慢旋转
        particles.rotation.y += 0.0005;
        particles.rotation.x += 0.0002;

        // 粒子消亡与重生逻辑 (模拟残影渐渐消亡)
        const alphaAttribute = geometry.attributes.alpha;
        const positionArray = geometry.attributes.position.array;
        
        for (let i = 0; i < alphaAttribute.count; i++) {
            // 随机缓慢降低透明度 (消亡)
            if (Math.random() < 0.01) {
                alphaAttribute.array[i] -= 0.05;
                if (alphaAttribute.array[i] <= 0) {
                    // 重置到中心，重新“出生”
                    alphaAttribute.array[i] = 1.0;
                    // 随机推到边缘
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.random() * Math.PI;
                    const radius = Math.random() * 15 + 10;
                    positionArray[i*3] = Math.sin(phi) * Math.cos(theta) * radius;
                    positionArray[i*3+1] = Math.sin(phi) * Math.sin(theta) * radius;
                    positionArray[i*3+2] = Math.cos(phi) * radius;
                }
            }
        }
        
        alphaAttribute.needsUpdate = true;
        geometry.attributes.position.needsUpdate = true;

        composer.render();
    }
    animate();

    // --- 窗口自适应 ---
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>
